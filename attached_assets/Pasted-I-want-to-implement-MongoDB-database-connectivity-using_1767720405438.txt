I want to implement MongoDB database connectivity using MongoDB Atlas / MongoDB Compass, following strict security rules for each email security level.

ğŸ¯ GOAL

Set up a secure MongoDB connection and level-wise database design so that:

Only allowed data is stored

Sensitive secrets are never stored

Each security level behaves differently

The database is safe even if breached

1ï¸âƒ£ MongoDB Connection Requirements

Use MongoDB (Atlas compatible with MongoDB Compass).

Use mongoose.

Connection string must be loaded from .env:

MONGODB_URI=mongodb+srv://<username>:<password>@cluster.mongodb.net/qumail


Create a reusable connection file (db.ts or database.ts).

Log successful connection.

Gracefully handle connection errors.

2ï¸âƒ£ COMMON DATA (FOR ALL EMAILS)

These fields must be stored for every email, regardless of security level:

email_id
sender_id
receiver_id
subject
timestamp
security_level
status (sent | read | expired)


âœ… These fields are non-sensitive
âŒ Do NOT store plaintext message here

3ï¸âƒ£ LEVEL-WISE DATABASE RULES (CRITICAL)
ğŸŸ¢ Level 1 â€“ Quantum OTP (Highest Security)
âœ… SAVE:
email_id
encrypted_message
otp_key_id
key_expiry_time
is_read

âŒ NEVER SAVE:

OTP key permanently

Plaintext message

ğŸ” RULES:

OTP keys must be stored in a temporary collection

Use TTL index to auto-delete keys after expiry

Delete OTP key immediately after first read

After deletion, message must be permanently undecryptable

Judge explanation:
â€œEven the server cannot recover the message after itâ€™s read.â€

ğŸŸ¡ Level 2 â€“ Quantum-Seeded AES-GCM
âœ… SAVE:
email_id
encrypted_message
iv
auth_tag
key_id (reference only)

âŒ NEVER SAVE:

Raw AES key

Plaintext message

ğŸ” KEY HANDLING:

AES key must be:

Derived per session OR

Stored encrypted using a server master key OR

Referenced via secure key ID

ğŸŸ  Level 3 â€“ CRYSTALS-Kyber (Post-Quantum)
âœ… SAVE:
email_id
encrypted_message
kyber_ciphertext
public_key_reference

âŒ NEVER SAVE:

Private keys

Plaintext message

ğŸ” RULES:

Private keys stay with the user

Database stores only public data + encrypted payload

Design must support future-proof encryption

âšª Level 4 â€“ Plain Text
âœ… SAVE:
email_id
plain_message
is_encrypted = false


âš ï¸ Must be clearly marked as unencrypted

4ï¸âƒ£ ABSOLUTE NEVER STORE (CRITICAL ğŸ”´)

âŒ Plain text of encrypted emails
âŒ Permanent OTP keys
âŒ Private encryption keys
âŒ Master encryption secrets
âŒ Decrypted message cache

If DB is hacked â†’ attackers must NOT read secure emails.

5ï¸âƒ£ DATABASE STRUCTURE (MongoDB)
ğŸ“ Emails Collection
{
  senderId: string,
  receiverId: string,
  subject: string,
  encryptedPayload: string,
  securityLevel: number,
  metadata: object,
  isRead: boolean,
  createdAt: Date
}

ğŸ“ OTP Keys Collection (TEMPORARY â€“ Level 1)
{
  emailId: ObjectId,
  otpKey: string,
  expiresAt: Date
}


Use TTL index on expiresAt

Auto-delete after expiry or read

6ï¸âƒ£ OUTPUT EXPECTED

MongoDB connection file

Mongoose schemas for:

Emails

OTP Keys (with TTL)

Example Express route saving data per level

Clear comments explaining:

Why each field is stored

Why certain data is never stored

MongoDB Compass-friendly schema

Focus on security correctness, clean architecture, and production-ready code.
Do NOT add placeholders or insecure shortcuts.